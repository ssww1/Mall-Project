# 答辩问题回答：非法操作与系统应对措施

## 问题：如果用户进行了一些非法操作（可能有哪些非法操作？）我们的系统分别如何应对？

---

## 一、可能存在的非法操作分类

### 1.1 身份认证相关
- **未授权访问**：未登录用户访问需要登录的页面
- **会话劫持**：伪造或盗用他人 Session
- **密码暴力破解**：尝试大量密码组合登录

### 1.2 权限越权相关
- **横向越权**：访问其他用户的订单、个人信息
- **纵向越权**：普通用户访问后台管理功能
- **伪造订单号支付**：修改订单 ID 支付他人订单

### 1.3 数据安全相关
- **SQL 注入**：通过输入恶意 SQL 语句攻击数据库
- **XSS 攻击**：注入恶意脚本代码
- **文件上传攻击**：上传恶意文件（木马、脚本等）

### 1.4 业务逻辑相关
- **重复提交订单**：快速多次点击提交按钮
- **购物车操作异常**：未登录操作购物车、修改商品数量为负数
- **空购物车下单**：购物车为空时提交订单

---

## 二、系统应对措施详解

### 2.1 未授权访问防护

#### 问题场景
用户未登录直接访问订单列表、购物车等需要登录的页面。

#### 系统应对

**实现位置**：`AuthorizationFilter.java`

```java
@Override
public void doFilter(ServletRequest req, ServletResponse res, 
                     FilterChain chain) throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest) req;
    String path = request.getRequestURL().toString();
    
    // 1) 只拦截 .do / .html 请求
    if (path.endsWith(".do") || path.endsWith(".html")) {
        // 2) 白名单放行（登录、注册、首页、商品浏览等）
        if (isWhitelist(path)) {
            chain.doFilter(request, response);
        } else {
            // 3) 非白名单：进入鉴权逻辑
            processAccessControl(request, response, chain);
        }
    }
}

private void processAccessControl(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain chain) {
    Object user = request.getSession().getAttribute("user");
    String url = request.getRequestURL().toString();
    
    // 前台用户相关 URL：要求 Session 中存在 "user"
    if (user == null) {
        // 未登录 → 重定向到登录页
        response.sendRedirect("/mall/user/toLogin.html");
    } else {
        chain.doFilter(request, response);
    }
}
```

**关键点**：
- Filter 统一拦截，避免在每个 Controller 中重复验证
- 白名单机制：公共资源（登录、注册、商品浏览）无需登录
- 未登录用户访问受限资源时自动重定向到登录页

---

### 2.2 横向越权防护（访问他人订单）

#### 问题场景
用户 A 尝试通过修改 URL 参数访问用户 B 的订单，例如：`/order/getDetail.do?orderId=123`（订单 123 属于用户 B）。

#### 系统应对

**实现位置**：`OrderServiceImpl.findUserOrder()`

```java
@Override
public List<Order> findUserOrder(HttpServletRequest request) {
    // 1) 从 Session 获取登录用户（无法伪造）
    Object user = request.getSession().getAttribute("user");
    if (user == null) {
        throw new LoginException("请登录！");
    }
    
    User loginUser = (User) user;
    
    // 2) 按 userId 查询订单（只查询当前登录用户的订单）
    return orderDao.findByUserId(loginUser.getId());
}
```

**关键点**：
- 订单查询基于 Session 中的用户 ID，而不是请求参数
- 用户只能查询自己的订单，无法通过修改 orderId 访问他人订单
- 数据库查询条件：`WHERE user_id = ?`，确保数据隔离

**注意**：当前实现中，`getDetail.do` 方法可能存在越权风险，建议添加订单归属校验：

```java
// 建议改进
@RequestMapping("/getDetail.do")
@ResponseBody
public ResultBean<List<OrderItem>> getDetail(int orderId, HttpServletRequest request) {
    // 1) 先查询订单，检查是否属于当前用户
    Order order = orderService.findById(orderId);
    User loginUser = (User) request.getSession().getAttribute("user");
    
    if (order == null || !order.getUserId().equals(loginUser.getId())) {
        throw new RuntimeException("订单不存在或无权限访问");
    }
    
    // 2) 查询订单项
    List<OrderItem> orderItems = orderService.findItems(orderId);
    return new ResultBean<>(orderItems);
}
```

---

### 2.3 纵向越权防护（普通用户访问后台）

#### 问题场景
普通用户尝试访问后台管理功能，例如：`/admin/user/toList.html`。

#### 系统应对

**实现位置**：`AuthorizationFilter.java`

```java
private void processAccessControl(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain chain) {
    Object adminUser = request.getSession().getAttribute("login_user");
    Object user = request.getSession().getAttribute("user");
    String url = request.getRequestURL().toString();
    
    // 1) 后台 URL：要求 login_user（管理员 Session）
    if (url.contains("admin")) {
        if (adminUser == null) {
            // 未登录后台 → 重定向后台登录页
            response.sendRedirect("/mall/admin/toLogin.html");
        } else {
            chain.doFilter(request, response);
        }
    } else {
        // 2) 前台用户相关 URL：要求 user（普通用户 Session）
        if (user == null) {
            response.sendRedirect("/mall/user/toLogin.html");
        } else {
            chain.doFilter(request, response);
        }
    }
}
```

**关键点**：
- 前后台使用不同的 Session key：`login_user`（后台）和 `user`（前台）
- 普通用户即使登录前台，也无法访问后台（因为 Session 中没有 `login_user`）
- URL 路径判断：包含 `admin` 的 URL 需要管理员权限

---

### 2.4 伪造订单号支付防护

#### 问题场景
用户尝试通过修改订单 ID 支付他人订单，例如：`/order/pay.do?orderId=999`（订单 999 属于其他用户）。

#### 系统应对

**当前实现**：`OrderServiceImpl.pay()`

```java
@Override
public void pay(int orderId) {
    // 1) 校验订单存在
    Order order = orderDao.findOne(orderId);
    if (order == null) {
        throw new RuntimeException("订单不存在");
    }
    
    // 2) 直接更新状态（当前实现未校验订单归属）
    orderDao.updateState(STATE_WAITE_SEND, order.getId());
}
```

**问题**：当前实现**存在越权风险**，未校验订单是否属于当前用户。

**建议改进**：

```java
@Override
public void pay(int orderId, HttpServletRequest request) {
    // 1) 校验订单存在
    Order order = orderDao.findOne(orderId);
    if (order == null) {
        throw new RuntimeException("订单不存在");
    }
    
    // 2) 校验订单归属（防止越权支付）
    User loginUser = (User) request.getSession().getAttribute("user");
    if (loginUser == null || !order.getUserId().equals(loginUser.getId())) {
        throw new RuntimeException("无权限操作此订单");
    }
    
    // 3) 校验订单状态（只能支付待支付订单）
    if (order.getState() != STATE_NO_PAY) {
        throw new RuntimeException("订单状态不正确");
    }
    
    // 4) 更新状态
    orderDao.updateState(STATE_WAITE_SEND, order.getId());
}
```

**关键点**：
- 必须校验订单归属，确保用户只能支付自己的订单
- 校验订单状态，防止重复支付或支付已完成订单

---

### 2.5 文件上传攻击防护

#### 问题场景
攻击者上传恶意文件（如 `.jsp`、`.php` 脚本、木马文件）到服务器。

#### 系统应对

**实现位置**：`FileUtil.saveFile()`

```java
public static String saveFile(MultipartFile file) throws Exception {
    // 1) 空文件检查
    if (file == null || file.isEmpty()) {
        return "";
    }
    
    // 2) 生成文件名：MD5(文件内容) + "." + 后缀
    String originalFilename = file.getOriginalFilename();
    MessageDigest md = MessageDigest.getInstance("MD5");
    md.update(file.getBytes());
    String fileName = (Helper.bytesToHex(md.digest(), 0, md.digest().length - 1)) 
                      + "." + getPostfix(originalFilename);
    
    // 3) 写入文件（CREATE_NEW 防止覆盖）
    Files.write(Paths.get(destFile.toURI()), file.getBytes(), 
                StandardOpenOption.CREATE_NEW);
    
    return "/mall/admin/product/img/" + fileName;
}
```

**关键点**：
- **MD5 命名**：使用文件内容的 MD5 值作为文件名，即使上传恶意文件，文件名也是随机哈希值，无法直接执行
- **保留原始后缀**：虽然保留了原始后缀，但由于文件名是 MD5，攻击者无法通过文件名猜测文件位置
- **CREATE_NEW**：防止文件覆盖，如果文件已存在会抛异常

**建议改进**（添加文件类型白名单）：

```java
// 建议添加文件类型白名单
private static final Set<String> ALLOWED_EXTENSIONS = 
    Set.of("jpg", "jpeg", "png", "gif", "bmp");

public static String saveFile(MultipartFile file) throws Exception {
    // ... 现有代码 ...
    
    // 添加文件类型校验
    String extension = getPostfix(originalFilename).toLowerCase();
    if (!ALLOWED_EXTENSIONS.contains(extension)) {
        throw new RuntimeException("不支持的文件类型：" + extension);
    }
    
    // ... 继续处理 ...
}
```

---

### 2.6 SQL 注入防护

#### 问题场景
攻击者通过输入恶意 SQL 语句，例如：`username = "admin' OR '1'='1"`。

#### 系统应对

**实现位置**：Spring Data JPA（自动防护）

```java
// 使用 Spring Data JPA 的查询方法，自动使用参数化查询
public interface UserDao extends JpaRepository<User, Integer> {
    List<User> findByUsername(String username);
    User findByUsernameAndPassword(String username, String password);
}
```

**关键点**：
- Spring Data JPA **自动使用参数化查询（PreparedStatement）**，防止 SQL 注入
- 所有查询都通过 JPA 方法，不会直接拼接 SQL 字符串
- 即使使用 `@Query` 注解，也应该使用参数绑定：`@Query("SELECT u FROM User u WHERE u.username = :username")`

**示例**（安全的查询方式）：

```java
// ✅ 安全：使用参数化查询
@Query("SELECT u FROM User u WHERE u.username = :username")
User findByUsername(@Param("username") String username);

// ❌ 危险：直接拼接 SQL（本项目未使用）
@Query("SELECT u FROM User u WHERE u.username = '" + username + "'")
User findByUsername(String username);
```

---

### 2.7 XSS 攻击防护

#### 问题场景
攻击者在输入框中注入恶意脚本，例如：`<script>alert('XSS')</script>`。

#### 系统应对

**实现位置**：Thymeleaf 模板引擎（自动转义）

```html
<!-- Thymeleaf 自动转义 HTML 特殊字符 -->
<div th:text="${product.title}"></div>
<!-- 如果 product.title = "<script>alert('XSS')</script>" -->
<!-- 输出：&lt;script&gt;alert('XSS')&lt;/script&gt; -->
```

**关键点**：
- Thymeleaf 使用 `th:text` 时**自动转义 HTML 特殊字符**，防止 XSS 攻击
- 如果确实需要输出 HTML，使用 `th:utext`（但需要确保内容安全）

**注意**：如果使用 `@ResponseBody` 返回 JSON，需要在前端进行转义，或使用 JSON 序列化库（如 Jackson）自动转义。

---

### 2.8 重复提交订单防护

#### 问题场景
用户快速多次点击"提交订单"按钮，导致重复创建订单。

#### 系统应对

**实现位置**：`OrderController.submit()`

```java
@RequestMapping("/submit.do")
public void submit(String name, String phone, String addr,
                   HttpServletRequest request, HttpServletResponse response) 
                   throws Exception {
    // 订单提交核心逻辑在 service 中
    orderService.submit(name, phone, addr, request, response);
    
    // 提交后重定向到订单列表页（避免刷新页面重复提交）
    // 注意：重定向在 service 中完成
}
```

**关键点**：
- **重定向策略**：提交后重定向到订单列表页，而不是返回成功页面
- 如果用户刷新页面，只会刷新订单列表，不会重复提交订单
- 使用 `@Transactional` 保证订单创建的原子性

**建议改进**（添加防重复提交 Token）：

```java
// 建议：在提交订单前生成 Token，提交时校验
@RequestMapping("/submit.do")
public void submit(String name, String phone, String addr,
                   String token,  // 防重复提交 Token
                   HttpServletRequest request, 
                   HttpServletResponse response) throws Exception {
    // 1) 校验 Token（从 Session 中获取并比较）
    String sessionToken = (String) request.getSession().getAttribute("submit_token");
    if (sessionToken == null || !sessionToken.equals(token)) {
        throw new RuntimeException("重复提交或 Token 无效");
    }
    
    // 2) 删除 Token（防止重复使用）
    request.getSession().removeAttribute("submit_token");
    
    // 3) 提交订单
    orderService.submit(name, phone, addr, request, response);
}
```

---

### 2.9 购物车操作异常防护

#### 问题场景
- 未登录用户操作购物车
- 修改商品数量为负数或 0
- 购物车为空时提交订单

#### 系统应对

**1. 未登录操作购物车**

**实现位置**：`ShopCartServiceImpl.addCart()`

```java
@Override
public void addCart(int productId, HttpServletRequest request) throws Exception {
    // 1) 获取登录用户（从 Session）
    User loginUser = getLoginUser(request);
    
    // 2) 获取购物车列表
    List<Integer> productIds = getCartList(loginUser, request);
    
    // 3) 追加商品 id
    productIds.add(productId);
}

private User getLoginUser(HttpServletRequest request) throws Exception {
    User loginUser = (User) request.getSession().getAttribute("user");
    if (loginUser == null) {
        throw new Exception("未登录！请重新登录");
    }
    return loginUser;
}
```

**关键点**：
- 所有购物车操作都先检查登录态
- 未登录时抛出异常，由全局异常处理器统一处理

**2. 空购物车下单**

**实现位置**：`OrderServiceImpl.submit()`

```java
@Override
@Transactional
public void submit(String name, String phone, String addr,
                   HttpServletRequest request, HttpServletResponse response) 
                   throws Exception {
    // ... 校验登录态 ...
    
    // 从购物车读取订单项
    List<OrderItem> orderItems = shopCartService.listCart(request);
    
    // 如果购物车为空，orderItems 为空列表，订单总价为 0
    // 建议添加校验：
    if (orderItems == null || orderItems.isEmpty()) {
        throw new RuntimeException("购物车为空，无法提交订单");
    }
    
    // ... 继续处理 ...
}
```

---

### 2.10 密码暴力破解防护

#### 问题场景
攻击者尝试大量密码组合登录，例如：使用脚本自动尝试常见密码。

#### 系统应对

**当前实现**：`UserServiceImpl.checkLogin()`

```java
@Override
public User checkLogin(String username, String password) {
    List<User> users = userDao.findByUsername(username);
    if (users == null || users.isEmpty()) {
        return null;
    }
    
    User user = users.get(0);
    
    // 使用 BCrypt 验证密码
    if (passwordEncoder.matches(password, user.getPassword())) {
        return user;
    }
    
    return null;
}
```

**当前问题**：未实现登录失败次数限制。

**建议改进**（添加登录失败次数限制）：

```java
// 建议：使用 Redis 或内存缓存记录登录失败次数
@Override
public User checkLogin(String username, String password) {
    // 1) 检查登录失败次数（从 Redis 或内存缓存）
    String failKey = "login_fail:" + username;
    Integer failCount = redisTemplate.get(failKey);
    
    if (failCount != null && failCount >= 5) {
        throw new LoginException("登录失败次数过多，请稍后再试");
    }
    
    // 2) 验证密码
    List<User> users = userDao.findByUsername(username);
    if (users == null || users.isEmpty()) {
        // 记录失败次数
        recordLoginFailure(username);
        return null;
    }
    
    User user = users.get(0);
    if (passwordEncoder.matches(password, user.getPassword())) {
        // 登录成功，清除失败记录
        redisTemplate.delete(failKey);
        return user;
    } else {
        // 密码错误，记录失败次数
        recordLoginFailure(username);
        return null;
    }
}

private void recordLoginFailure(String username) {
    String failKey = "login_fail:" + username;
    Integer failCount = redisTemplate.get(failKey);
    if (failCount == null) {
        redisTemplate.set(failKey, 1, 300); // 5 分钟过期
    } else {
        redisTemplate.set(failKey, failCount + 1, 300);
    }
}
```

---

### 2.11 全局异常处理

#### 系统应对

**实现位置**：`GlobalExceptionHandler.java`

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger LOGGER = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    /**
     * 默认异常处理：记录日志并返回错误信息
     */
    @ExceptionHandler(value = Exception.class)
    @ResponseBody
    public ResultBean<String> defaultErrorHandler(HttpServletRequest req, Exception e) {
        // 记录日志（便于排查问题）
        LOGGER.error(e.getMessage(), e);
        e.printStackTrace();
        
        // 返回统一错误格式
        ResultBean<String> r = new ResultBean<>(e);
        r.setData(req.getRequestURI());
        return r;
    }
    
    /**
     * RuntimeException 处理：转发到错误页面
     */
    @ExceptionHandler(value = RuntimeException.class)
    public void runtimeExceptionHandler(HttpServletRequest req, 
                                       HttpServletResponse res, 
                                       Exception e) throws Exception {
        LOGGER.error(e.getMessage(), e);
        req.setAttribute("msg", e.getMessage());
        // 转发到错误页面
        req.getRequestDispatcher("/mall/user/error.html").forward(req, res);
    }
}
```

**关键点**：
- 统一异常处理，避免异常信息泄露给用户
- 记录日志，便于排查安全问题
- 返回统一的错误格式，提升用户体验

---

## 三、安全防护总结

### 3.1 已实现的安全措施

| 安全措施 | 实现位置 | 防护效果 |
|---------|---------|---------|
| 未授权访问防护 | `AuthorizationFilter` | ✅ 已实现 |
| 横向越权防护（订单查询） | `OrderServiceImpl.findUserOrder()` | ✅ 已实现 |
| 纵向越权防护（后台访问） | `AuthorizationFilter` | ✅ 已实现 |
| SQL 注入防护 | Spring Data JPA | ✅ 已实现 |
| XSS 攻击防护 | Thymeleaf 自动转义 | ✅ 已实现 |
| 文件上传安全 | `FileUtil.saveFile()`（MD5 命名） | ✅ 部分实现 |
| 全局异常处理 | `GlobalExceptionHandler` | ✅ 已实现 |
| 密码加密存储 | BCrypt 加盐哈希 | ✅ 已实现 |

### 3.2 需要改进的安全措施

| 安全措施 | 当前状态 | 建议改进 |
|---------|---------|---------|
| 伪造订单号支付 | ⚠️ 存在风险 | 添加订单归属校验 |
| 订单详情越权 | ⚠️ 存在风险 | 添加订单归属校验 |
| 重复提交订单 | ⚠️ 部分防护 | 添加防重复提交 Token |
| 密码暴力破解 | ⚠️ 未实现 | 添加登录失败次数限制 |
| 文件类型白名单 | ⚠️ 未实现 | 限制允许上传的文件类型 |

---

## 四、答辩回答要点

### 4.1 核心回答

**问题**：如果用户进行了一些非法操作，我们的系统分别如何应对？

**回答要点**：

1. **未授权访问防护**：
   - 通过 `AuthorizationFilter` 统一拦截，检查 Session 登录态
   - 未登录用户访问受限资源时自动重定向到登录页

2. **越权操作防护**：
   - **横向越权**：订单查询基于 Session 中的用户 ID，用户只能查询自己的订单
   - **纵向越权**：前后台使用不同的 Session key，普通用户无法访问后台

3. **数据安全防护**：
   - **SQL 注入**：使用 Spring Data JPA 的参数化查询，自动防护
   - **XSS 攻击**：Thymeleaf 模板引擎自动转义 HTML 特殊字符
   - **文件上传**：使用 MD5 命名文件，防止恶意文件直接执行

4. **业务逻辑防护**：
   - 购物车操作前检查登录态
   - 订单提交后重定向，防止重复提交
   - 使用事务保证订单创建的原子性

5. **异常处理**：
   - 全局异常处理器统一处理异常，记录日志，返回统一错误格式

### 4.2 改进建议（可选回答）

如果被问到系统还有哪些可以改进的地方，可以提到：

1. **订单支付和详情查询**：添加订单归属校验，防止越权操作
2. **防重复提交**：添加 Token 机制，防止重复提交订单
3. **登录安全**：添加登录失败次数限制，防止暴力破解
4. **文件上传**：添加文件类型白名单，限制允许上传的文件类型

---

## 五、代码示例总结

### 5.1 权限控制核心代码

```java
// AuthorizationFilter.java
if (user == null) {
    response.sendRedirect("/mall/user/toLogin.html");
}
```

### 5.2 数据隔离核心代码

```java
// OrderServiceImpl.findUserOrder()
User loginUser = (User) request.getSession().getAttribute("user");
return orderDao.findByUserId(loginUser.getId());  // 只查询当前用户的订单
```

### 5.3 异常处理核心代码

```java
// GlobalExceptionHandler.java
@ExceptionHandler(value = Exception.class)
@ResponseBody
public ResultBean<String> defaultErrorHandler(HttpServletRequest req, Exception e) {
    LOGGER.error(e.getMessage(), e);  // 记录日志
    return new ResultBean<>(e);  // 返回统一错误格式
}
```

---

## 六、总结

我们的系统通过 **Filter 统一权限控制**、**Session 管理用户状态**、**数据隔离查询**、**全局异常处理** 等多层防护机制，有效应对了未授权访问、越权操作、SQL 注入、XSS 攻击等常见安全问题。同时，我们也认识到系统在某些方面（如订单支付归属校验、防重复提交）还有改进空间，这些都可以作为后续优化的方向。

