# 过程文档

> 版本：v1.0（重构）
> 生成日期：2026-01-02

---

## 第一章　版本控制记录（版本更迭记录）

> 说明：由于时间紧张，开发阶段未进行严格的“每天提交 + 分支管理”，而是在功能稳定后集中整理代码并统一提交。  
> 下面按“实际开发里程碑”对版本演进进行更细致的记录，便于答辩时说明团队如何逐步实现功能。

### 1.1 版本记录总览（里程碑）

| 里程碑 | 阶段目标 | 产出物/影响范围 |
|---|---|---|
| M1 | 搭建项目骨架与基础 UI | Spring Boot 启动、模板结构、LayUI 静态资源、基础页面路由 |
| M2 | 完成核心业务功能（前后台） | 商品/分类/购物车/订单的主要接口与页面交互 |
| M3 | 建库建表与示例数据 | `mall.sql`、MySQL 连接配置、初始分类/商品/管理员数据 |
| M4 | 登录体系与鉴权 | Session 登录态、`AuthorizationFilter`、全局异常处理 |
| M5 | 测试用例建设 | 单元测试/MockMvc/Filter 测试、H2 测试配置 |
| M6 | Bug 修复与 UI 体验优化 | 表单校验、交互提示、分页体验、异常提示统一 |
| M7 | 安全加固：密码哈希与上传校验 | BCrypt 加盐哈希、上传图片后缀白名单、异常提示完善 |

---

### 1.2 M1：项目骨架与基础 UI
**目标**：尽快跑通“能访问页面、能启动服务、能看到前后台入口”的最小可用版本（MVP）。

**关键实现点**：
- Maven 工程初始化与依赖管理（`pom.xml`）：引入 `spring-boot-starter-web`、`thymeleaf`、`spring-data-jpa` 等。
- 应用入口类（`MallApplication.java`）：启动 Spring Boot，并开启对自定义 Filter 的扫描（`@ServletComponentScan`）。
- 模板目录结构：
  - 前台：`templates/mall/**`
  - 后台：`templates/admin/**`
  - 静态资源：`static/**`（LayUI、CSS、JS）

**实际代码（`MallApplication.java`）**：
```java
@SpringBootApplication
@ServletComponentScan // 扫描自定义 Filter（如 AuthorizationFilter）
@EnableTransactionManagement // 开启事务
public class MallApplication {
    public static void main(String[] args) {
        SpringApplication.run(MallApplication.class, args);
    }
}
```

---

### 1.3 M2：核心业务开发（商品/分类/购物车/订单）
**目标**：实现完整的“浏览商品 → 加入购物车 → 提交订单 → 查询订单”的前台闭环；同时提供后台对商品、分类、订单、用户的基础管理能力。

**关键模块与实现方式**：
- **商品查询与详情**：`ProductController` + `ProductServiceImpl` + `ProductDao`
  - 热门商品：`/product/hot.do`
  - 最新商品分页：`/product/new.do`
- **购物车（Session 方案）**：`ShopCartServiceImpl`
  - 购物车不落库，按用户维度写入 Session：`NAME_PREFIX + userId -> List<Integer>`
- **订单提交（事务）**：`OrderServiceImpl.submit()`
  - 创建订单主表（Order）→ 写入订单项（OrderItem）→ 回写 total

**实际代码（`ShopCartServiceImpl.java`）**：
```java
@Override
public void addCart(int productId, HttpServletRequest request) throws Exception {
    User loginUser = getLoginUser(request);
    List<Integer> productIds = (List<Integer>) request.getSession().getAttribute(NAME_PREFIX + loginUser.getId());
    if (productIds == null) {
        productIds = new ArrayList<>();
        request.getSession().setAttribute(NAME_PREFIX + loginUser.getId(), productIds);
    }
    productIds.add(productId);
}
```

---

### 1.4 M3：数据库建库建表、示例数据与连接
**目标**：形成可一键初始化的数据库脚本，使项目可快速部署演示。

**关键产出**：
- `mall.sql`：包含表结构（`admin_user`、`user`、`product`、`classification`、`order`、`order_item`）与示例数据。
- `application.properties`：MySQL 连接与端口配置。

**实际配置（`application.properties`）**：
```properties
server.port=8081
server.context-path=/mall
spring.datasource.url=jdbc:mysql://localhost:3306/mall?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=root
```

---

### 1.5 M4：登录注册与权限鉴权
**目标**：实现前台用户与后台管理员两套登录体系，并对受限页面进行统一拦截。

**实现要点**：
- **前台登录态**：`session.setAttribute("user", user)`
- **后台登录态**：`session.setAttribute("login_user", adminUser)`
- **统一鉴权**：`AuthorizationFilter`
  - URL 含 `admin` → 检查 `login_user`
  - 否则 → 检查 `user`

**实际代码（`AuthorizationFilter.java`）**：
```java
private void processAccessControl(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
        throws IOException, ServletException {
    Object adminUser = request.getSession().getAttribute("login_user");
    Object user = request.getSession().getAttribute("user");
    String url = request.getRequestURL().toString();

    if (url.contains("admin")) {
        if (adminUser == null) {
            response.sendRedirect("/mall/admin/toLogin.html");
        }
    } else {
        if (user == null) {
            response.sendRedirect("/mall/user/toLogin.html");
        }
    }
    chain.doFilter(request, response);
}
```

---

### 1.6 M5：测试用例建设
**目标**：为核心逻辑提供可重复验证的测试，避免回归问题。

**关键产出**：
- 测试 profile 配置：`src/test/resources/application-test.properties`（H2 内存库 + 禁用 Druid WebStatFilter）
- 单元测试：Service、Utils、Filter、MockMvc Controller 测试

**实际配置（`application-test.properties`）**：
```properties
spring.datasource.druid.web-stat-filter.enabled=false
spring.datasource.druid.stat-view-servlet.enabled=false
```

---

### 1.7 M6：Bug 修复与 UI 体验优化
**目标**：提升演示稳定性与用户体验。

典型修复项：
- 修复后台用户编辑提示文案（“更新改用户信” → “更新用户信息”）并在成功后返回列表页。
- 修复分页交互、表单校验提示、异常提示一致性。

**实际代码（`admin/user/edit.html`）**：
```javascript
success: function(result) {
    if(result.state==0){
        alert("修改成功！");
        // 修改成功后返回上一页（通常为用户列表页）
        history.back();
    }else{
        alert(result.message);
    }
}
```

---

### 1.8 M7：安全加固（BCrypt 密码哈希 & 上传类型校验）
**目标**：在答辩前补齐关键安全点，避免“明文密码/任意文件上传”等风险被追问。

**已完成改动**：
1. **密码存储升级**：用户与管理员密码使用 BCrypt 加盐哈希存储。
   - 用户：`UserServiceImpl.create/update/checkLogin`
   - 管理员：`AdminUserServiceImpl.create/update/checkLogin`

**实际代码（`UserServiceImpl.java`）**：
```java
@Override
public User checkLogin(String username, String password) {
    List<User> users = userDao.findByUsername(username);
    if (users == null || users.isEmpty()) {
        return null;
    }
    User user = users.get(0);
    if (passwordEncoder.matches(password, user.getPassword())) {
        return user;
    }
    return null;
}
```

2. **图片上传白名单**：只允许上传 jpg/jpeg/png/gif/bmp/webp。

**实际代码（`FileUtil.java`）**：
```java
private static final Set<String> ALLOWED_IMAGE_EXTENSIONS = new HashSet<>(
        Arrays.asList("jpg", "jpeg", "png", "gif", "bmp", "webp")
);

// ...

String extension = getPostfix(originalFilename).toLowerCase();
if (!ALLOWED_IMAGE_EXTENSIONS.contains(extension)) {
    throw new IllegalArgumentException("不支持的文件类型");
}
```

---

> 注：以上里程碑对应的代码均已在仓库中落地，可结合答辩演示进行讲解。

---

## 第二章　关键决策日志

1. 选题与主题确定：聚焦单商户 B2C 模式，避免多商户 SaaS 复杂度。
2. 架构分层：采纳经典 **前后台分离 + Thymeleaf 服务端渲染**，前端不引入 React/Vue，降低部署门槛。
3. 系统角色：除普通用户和管理员外，显式保留“游客”角色以支持无登录浏览。
4. 数据库：采用 MySQL 8.0；开发期使用内存 H2，保证单元测试自包含。
5. ORM 方案：使用 **Spring Data JPA**，快速生成 Repository，避免手写 SQL。
6. 支付策略：出于演示目的，订单支付仅做状态流转，不接入真实第三方网关。
7. Session 购物车：权衡开发成本与并发需求，购物车数据保存在 HTTP Session 而非 Redis。
8. 安全边界：敏感 URL 统一经过 `AuthorizationFilter`，同时关闭 Thymeleaf 非转义输出，降低 XSS 风险。
9. 密码加密方案：采用 **BCrypt 加盐哈希**存储用户和管理员密码，替代原有的明文/DES 加密方式。BCrypt 每次加密结果不同但可通过 `matches()` 验证，自动加盐，安全性更高。

---

## 第三章　测试与部署说明

### 3.1 测试策略

本项目遵循“单元 → 集成 → Web 层”由内到外的金字塔测试模型。（详细方案见《测试方案.md）

1. **单元测试**

   - 范围：工具类（FileUtil 等）、业务 Service 的纯逻辑分支。
   - 工具：JUnit4 + Mockito，Spring 容器不启动，执行速度快。
2. **Spring Boot 集成测试**

   - 范围：Service × Dao × JPA Repository 交互与事务回滚。
   - 工具：`@RunWith(SpringRunner.class)` + `@SpringBootTest`，数据源使用 H2 内存库并在 `application-test.properties` 中开启 `ddl-auto=create-drop`。
3. **Web 层测试（MockMvc）**

   - 范围：前台/后台 Controller 的路由、参数校验、Session 鉴权、JSON 返回与重定向。
   - 工具：`MockMvcBuilders.webAppContextSetup` + `@AutoConfigureMockMvc`。
4. **过滤器 & 切面**

   - `AuthorizationFilter` 通过 MockHttpServletRequest/Response 进行重定向验证。
   - `GlobalExceptionHandler` 通过触发异常的 Controller 场景进行断言。
5. **覆盖率目标**

   - utils ≥ 90%；service ≥ 80%；filter/aspect ≥ 70%；controller ≥ 60%。
   - 使用 Jacoco（Maven 插件）生成 `target/site/jacoco/index.html` 覆盖率报告。
6. **用例管理**

   - 测试用例命名 `xxxTest`（单元）、`xxxIT`（集成），路径 `src/test/java`.
   - Maven 默认执行：`mvn test`；生成覆盖率：`mvn test jacoco:report`。

### 3.2 实际测试实现（关键代码示例）

> 以下为各分层测试的典型实现，展示了如何运用 Mockito、MockMvc 等工具对业务逻辑、安全边界和 Web 交互进行验证。

#### 1. 工具类（Utils）单元测试
**目标**：验证工具类的边界条件与核心逻辑，不依赖 Spring 容器。

**示例**：`FileUtilTest.java` - 验证文件上传的重复写入场景
```java
// FileUtilTest.java
@Test(expected = java.nio.file.FileAlreadyExistsException.class)
public void saveFile_duplicateContent_throwException() throws Exception {
    byte[] data = "duplicate".getBytes();
    MockMultipartFile file1 = new MockMultipartFile("img", "dup.png", "image/png", data);
    MockMultipartFile file2 = new MockMultipartFile("img", "dup.png", "image/png", data);

    // 第一次保存成功
    FileUtil.saveFile(file1);
    // 第二次保存相同 MD5 -> 相同文件名，期望抛 FileAlreadyExistsException
    FileUtil.saveFile(file2);
}
```
**实现说明**：使用 `MockMultipartFile` 模拟上传，通过 `@Test(expected=...)` 断言当写入同内容文件时，`FileUtil` 会因 `StandardOpenOption.CREATE_NEW` 选项而抛出 `FileAlreadyExistsException`，符合预期。

---

#### 2. 业务层（Service）单元测试
**目标**：使用 Mockito 隔离 Dao 层依赖，专注测试 Service 内部的业务分支与逻辑正确性。

**示例**：`UserServiceImplTest.java` - 验证 BCrypt 登录成功
```java
// UserServiceImplTest.java
@RunWith(MockitoJUnitRunner.class)
public class UserServiceImplTest {
    @Mock
    private UserDao userDao;
    @InjectMocks
    private UserServiceImpl userService;

    @Test
    public void checkLogin_success_shouldReturnUser() {
        // 1) 准备：Mock findByUsername 返回一个已加密密码的用户
        User demo = new User();
        demo.setUsername("demo");
        demo.setPassword(new BCryptPasswordEncoder().encode("123"));
        when(userDao.findByUsername("demo")).thenReturn(Collections.singletonList(demo));

        // 2) 执行
        User u = userService.checkLogin("demo", "123");

        // 3) 断言：返回的用户不为 null
        assertNotNull(u);
    }
}
```
**实现说明**：通过 `@Mock` 和 `@InjectMocks` 注入依赖，使用 `when(...).thenReturn(...)` 伪造 Dao 返回值，从而在不访问数据库的情况下验证 `checkLogin` 方法能否正确调用 BCrypt 的 `matches` 方法并返回用户。

---

#### 3. 过滤器（Filter）单元测试
**目标**：验证 `AuthorizationFilter` 对不同 URL 的拦截与放行逻辑是否正确。

**示例**：`AuthorizationFilterTest.java` - 验证未登录访问后台被重定向
```java
// AuthorizationFilterTest.java
@Test
public void doFilter_adminUrl_withoutLogin_redirectToAdminLogin() throws Exception {
    // 1) 准备：Mock Servlet API
    HttpServletRequest req = mock(HttpServletRequest.class);
    HttpServletResponse res = mock(HttpServletResponse.class);
    FilterChain chain = mock(FilterChain.class);
    HttpSession session = mock(HttpSession.class);

    // 2) 伪造一个未登录访问后台的场景
    when(req.getRequestURL()).thenReturn(new StringBuffer("http://.../mall/admin/user/toList.html"));
    when(req.getSession()).thenReturn(session);
    when(session.getAttribute("login_user")).thenReturn(null);

    // 3) 执行
    new AuthorizationFilter().doFilter(req, res, chain);

    // 4) 断言：重定向到后台登录页，且请求链未继续
    verify(res).sendRedirect("/mall/admin/toLogin.html");
    verify(chain, never()).doFilter(req, res);
}
```
**实现说明**：完全 Mock Servlet API，构造“未登录访问后台”的场景，通过 `verify` 断言 `sendRedirect` 被调用，而 `chain.doFilter` 未被调用，证明拦截成功。

---

#### 4. Web 层（Controller）集成测试
**目标**：使用 MockMvc 模拟 HTTP 请求，验证 Controller 的路由、参数绑定、Session 写入、重定向与 JSON 返回是否符合预期。

**示例**：`UserControllerTest.java` - 验证登录成功
```java
// UserControllerTest.java
@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class UserControllerTest {
    @Autowired
    private MockMvc mockMvc;
    @MockBean
    private UserService userService;

    @Test
    public void login_success_shouldRedirectAndWriteSession() throws Exception {
        // 1) 准备：Mock Service 返回一个用户
        User u = new User(); u.setUsername("demo");
        when(userService.checkLogin("demo","123")).thenReturn(u);
        MockHttpSession session = new MockHttpSession();

        // 2) 执行：模拟 POST 请求
        mockMvc.perform(post("/user/login.do")
                .param("username","demo").param("password","123")
                .session(session))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/mall/index.html"));

        // 3) 断言：Session 中已写入 user 对象
        assertNotNull(session.getAttribute("user"));
    }
}
```
**实现说明**：使用 `@SpringBootTest` 启动一个测试容器，`@MockBean` 替换真实 Service，通过 `mockMvc.perform` 模拟用户提交表单，最后用 `andExpect` 断言 HTTP 状态码、重定向 URL，并检查 `MockHttpSession` 中是否写入了登录凭证。

### 3.3 部署步骤（本地开发环境）

1. **克隆代码**

   ```bash
   git clone https://github.com/ssww1/Mall-Project
   cd mall
   ```
2. **数据库准备**

   - 安装 MySQL 8.0，创建空库 mall；
   - 执行根目录 `mall.sql` 导入表结构与示例数据：
     ```bash
     mysql -u<user> -p mall < mall.sql
     ```
3. **IDEA 运行**

   - 使用 IntelliJ IDEA 打开项目，确认 Maven 自动下载依赖；
   - 修改 `src/main/resources/application.properties` 中数据库连接：
     ```properties
     spring.datasource.url=jdbc:mysql://localhost:3306/mall?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC
     spring.datasource.username=<user>
     spring.datasource.password=<password>
     ```
4. **启动应用**

   - 方式一：IDEA 直接运行 `MallApplication.java`；
   - 方式二：命令行打包并执行：
     ```bash
     mvn clean package -DskipTests
     java -jar target/mall.jar
     ```

   默认端口 8081（可在 `application.properties` 修改）。
5. **访问地址**

   - 前台门户：  `http://127.0.0.1:8081/mall`
   - 后台管理：  `http://127.0.0.1:8081/mall/admin`
6. **默认账户**

   | 角色     | 用户名 | 密码  |
   | -------- | ------ | ----- |
   | 管理员   | admin  | admin |
   | 普通用户 | 111    | 12345 |

> 若端口占用，可通过 `server.port` 改为其他端口。

---

> 文档完。
