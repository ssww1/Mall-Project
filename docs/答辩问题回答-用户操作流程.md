# 答辩问题回答：用户操作流程及代码实现

## 问题：目前整个用户操作的流程是什么样的？代码方面如何实现？

---

## 一、用户操作流程概述

整个系统分为**前台用户端**和**后台管理端**两个部分。前台用户操作流程如下：

### 1.1 用户注册与登录流程

```
访问首页 → 注册/登录 → 浏览商品 → 加入购物车 → 提交订单 → 支付 → 查看订单
```

### 1.2 详细流程步骤

1. **用户注册**
   - 访问注册页面 → 填写信息 → 提交注册 → 重定向到登录页

2. **用户登录**
   - 访问登录页面 → 输入用户名密码 → 服务端验证 → 写入 Session → 重定向首页

3. **浏览商品**
   - 首页展示热门/最新商品 → 按分类浏览 → 查看商品详情

4. **购物车操作**
   - 加入购物车 → 查看购物车 → 修改数量/删除商品

5. **下单流程**
   - 填写收货信息 → 提交订单 → 生成订单主表和订单项表 → 清空购物车

6. **支付与订单管理**
   - 支付订单（模拟）→ 查看订单列表 → 查看订单详情 → 确认收货

---

## 二、代码实现架构

### 2.1 技术架构

```
Controller 层（Web 层）
    ↓
Service 层（业务逻辑层）
    ↓
DAO 层（数据访问层）
    ↓
Entity 层（实体层）
    ↓
Database（MySQL）
```

### 2.2 关键技术点

- **Spring Boot MVC**：处理 HTTP 请求
- **Thymeleaf**：服务端模板渲染
- **Spring Data JPA**：数据持久化
- **Session 管理**：用户登录态和购物车数据
- **Filter 拦截器**：权限控制

---

## 三、核心流程代码实现

### 3.1 用户注册流程

**Controller 层**：`UserController.register()`

```java
@RequestMapping("/register.do")
public void register(String username, String password, String name, 
                     String phone, String email, String addr,
                     HttpServletResponse response) throws IOException {
    // 1) 组装用户对象
    User user = new User();
    user.setUsername(username);
    user.setPassword(password);  // Service 层会自动 BCrypt 加密
    // ... 设置其他字段
    
    // 2) 调用 Service 保存用户
    userService.create(user);
    
    // 3) 注册成功后重定向到登录页
    response.sendRedirect("/mall/user/toLogin.html");
}
```

**Service 层**：`UserServiceImpl.create()`

```java
@Override
public int create(User user) {
    // 1) 注册时对密码进行 BCrypt 加密（自动加盐）
    String rawPassword = user.getPassword();
    String encodedPassword = passwordEncoder.encode(rawPassword);
    user.setPassword(encodedPassword);
    
    // 2) 保存用户并返回主键
    return userDao.save(user).getId();
}
```

**关键点**：
- 密码使用 BCrypt 加密存储，自动加盐
- 注册成功后重定向，避免重复提交

---

### 3.2 用户登录流程

**Controller 层**：`UserController.login()`

```java
@RequestMapping("/login.do")
public void login(String username, String password,
                  HttpServletRequest request, HttpServletResponse response) 
                  throws IOException {
    // 1) 调用 Service 校验用户名密码
    User user = userService.checkLogin(username, password);
    
    if (user != null) {
        // 2) 登录成功：将用户对象写入 Session（key="user"）
        request.getSession().setAttribute("user", user);
        
        // 3) 重定向到首页
        response.sendRedirect("/mall/index.html");
    } else {
        // 4) 登录失败：抛出异常，由全局异常处理器处理
        throw new LoginException("登录失败！用户名或者密码错误");
    }
}
```

**Service 层**：`UserServiceImpl.checkLogin()`

```java
@Override
public User checkLogin(String username, String password) {
    // 1) 根据用户名查询用户
    List<User> users = userDao.findByUsername(username);
    if (users == null || users.isEmpty()) {
        return null;
    }
    
    User user = users.get(0);
    
    // 2) 使用 BCrypt 验证密码：matches(明文密码, BCrypt 密文)
    if (passwordEncoder.matches(password, user.getPassword())) {
        return user;
    }
    
    return null;
}
```

**关键点**：
- 使用 BCrypt 的 `matches()` 方法验证密码
- 登录成功后用户信息存储在 Session 中，供后续鉴权使用

---

### 3.3 权限控制（Filter 拦截器）

**AuthorizationFilter**：统一处理权限验证

```java
@Override
public void doFilter(ServletRequest req, ServletResponse res, 
                     FilterChain chain) throws IOException, ServletException {
    HttpServletRequest request = (HttpServletRequest) req;
    String path = request.getRequestURL().toString();
    
    // 1) 只拦截 .do / .html 请求（静态资源放行）
    if (path.endsWith(".do") || path.endsWith(".html")) {
        // 2) 白名单放行（登录、注册、首页、商品浏览等）
        if (isWhitelist(path)) {
            chain.doFilter(request, response);
        } else {
            // 3) 非白名单：进入鉴权逻辑
            processAccessControl(request, response, chain);
        }
    }
}

private void processAccessControl(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain chain) {
    Object user = request.getSession().getAttribute("user");
    String url = request.getRequestURL().toString();
    
    // 前台用户相关 URL：要求 Session 中存在 "user"
    if (user == null) {
        response.sendRedirect("/mall/user/toLogin.html");
    } else {
        chain.doFilter(request, response);
    }
}
```

**关键点**：
- 通过 Filter 统一拦截，避免在每个 Controller 中重复验证
- 白名单机制：登录、注册、商品浏览等公共资源无需登录
- Session 检查：未登录用户访问受限资源时重定向到登录页

---

### 3.4 购物车操作流程

**加入购物车**：`ShopCartServiceImpl.addCart()`

```java
@Override
public void addCart(int productId, HttpServletRequest request) throws Exception {
    // 1) 获取登录用户（从 Session）
    User loginUser = getLoginUser(request);
    
    // 2) 获取该用户购物车列表（Session key = "cart_" + userId）
    List<Integer> productIds = getCartList(loginUser, request);
    
    // 3) 追加商品 id（允许重复，后续统计数量）
    productIds.add(productId);
}
```

**查看购物车**：`ShopCartServiceImpl.listCart()`

```java
@Override
public List<OrderItem> listCart(HttpServletRequest request) throws Exception {
    User loginUser = getLoginUser(request);
    List<Integer> productIds = (List<Integer>) 
        request.getSession().getAttribute("cart_" + loginUser.getId());
    
    // 1) 将 productId List 聚合为 OrderItem 列表
    Map<Integer, OrderItem> productMap = new HashMap<>();
    
    for (Integer pid : productIds) {
        if (!productMap.containsKey(pid)) {
            // 首次出现：创建 OrderItem，数量=1
            Product product = productService.findById(pid);
            OrderItem item = new OrderItem();
            item.setProduct(product);
            item.setCount(1);
            item.setSubTotal(product.getShopPrice());
            productMap.put(pid, item);
        } else {
            // 已存在：数量+1，小计累加
            OrderItem item = productMap.get(pid);
            item.setCount(item.getCount() + 1);
            item.setSubTotal(item.getSubTotal() + item.getProduct().getShopPrice());
        }
    }
    
    return new ArrayList<>(productMap.values());
}
```

**关键点**：
- 购物车数据存储在 Session 中，以 `"cart_" + userId` 作为 key
- 使用 List 存储商品 id，允许重复以表示数量
- 查看购物车时聚合相同商品，计算总数量和总价

---

### 3.5 下单流程

**提交订单**：`OrderServiceImpl.submit()`

```java
@Override
@Transactional  // 事务注解：保证订单主表和订单项表的原子性
public void submit(String name, String phone, String addr,
                   HttpServletRequest request, HttpServletResponse response) 
                   throws Exception {
    // 1) 校验登录态
    User loginUser = (User) request.getSession().getAttribute("user");
    if (loginUser == null) {
        throw new LoginException("请登录！");
    }
    
    // 2) 组装订单对象
    Order order = new Order();
    order.setName(name);
    order.setPhone(phone);
    order.setAddr(addr);
    order.setOrderTime(new Date());
    order.setUserId(loginUser.getId());
    order.setState(STATE_NO_PAY);  // 初始状态：待支付
    
    // 3) 从购物车读取订单项
    List<OrderItem> orderItems = shopCartService.listCart(request);
    
    // 4) 先保存订单主表，获取 orderId
    order.setTotal(0.0);  // 先写 0，后续回写
    order = orderDao.save(order);
    
    // 5) 保存订单项并累计总价
    Double total = 0.0;
    for (OrderItem orderItem : orderItems) {
        orderItem.setOrderId(order.getId());
        total += orderItem.getSubTotal();
        orderItemDao.save(orderItem);
    }
    
    // 6) 回写订单总价
    order.setTotal(total);
    orderDao.save(order);
    
    // 7) 重定向到订单列表页
    response.sendRedirect("/mall/order/toList.html");
}
```

**关键点**：
- 使用 `@Transactional` 保证订单主表和订单项表的原子性
- 先保存订单主表获取 orderId，再保存订单项表
- 订单总价通过累加订单项小计得到

---

### 3.6 支付与订单管理

**支付订单**：`OrderServiceImpl.pay()`

```java
@Override
public void pay(int orderId) {
    // 1) 校验订单存在
    Order order = orderDao.findOne(orderId);
    if (order == null) {
        throw new RuntimeException("订单不存在");
    }
    
    // 2) 更新订单状态为"待发货"（模拟支付）
    orderDao.updateState(STATE_WAITE_SEND, order.getId());
}
```

**查看订单列表**：`OrderServiceImpl.findUserOrder()`

```java
@Override
public List<Order> findUserOrder(HttpServletRequest request) {
    // 1) 从 Session 获取登录用户
    User loginUser = (User) request.getSession().getAttribute("user");
    if (loginUser == null) {
        throw new LoginException("请登录！");
    }
    
    // 2) 按 userId 查询订单
    return orderDao.findByUserId(loginUser.getId());
}
```

**关键点**：
- 支付为模拟实现，仅更新订单状态
- 订单查询基于 Session 中的用户 id，保证数据隔离

---

## 四、数据流转图

```
用户请求
    ↓
AuthorizationFilter（权限拦截）
    ↓
Controller（接收请求，参数绑定）
    ↓
Service（业务逻辑处理）
    ↓
DAO（数据持久化）
    ↓
Database（MySQL）
    ↓
返回结果（JSON/HTML）
```

---

## 五、关键技术亮点

### 5.1 Session 管理
- **用户登录态**：`Session["user"]` 存储当前登录用户
- **购物车数据**：`Session["cart_" + userId]` 存储购物车商品列表
- **后台登录态**：`Session["login_user"]` 存储后台管理员

### 5.2 密码安全
- 使用 **BCrypt** 加盐哈希存储密码
- 每次加密结果不同，但可通过 `matches()` 方法验证
- 注册和更新时自动加密

### 5.3 事务管理
- 使用 `@Transactional` 保证订单提交的原子性
- 订单主表和订单项表要么全部成功，要么全部回滚

### 5.4 权限控制
- Filter 统一拦截，避免代码重复
- 白名单机制：公共资源无需登录
- 前后台分离：不同的 Session key 区分用户和管理员

---

## 六、总结

整个用户操作流程采用经典的 **MVC 三层架构**，通过 **Session 管理用户状态**，使用 **Filter 统一权限控制**，保证了系统的安全性和可维护性。关键业务逻辑集中在 Service 层，Controller 层负责请求处理和响应，DAO 层负责数据持久化，职责清晰，便于扩展和维护。

